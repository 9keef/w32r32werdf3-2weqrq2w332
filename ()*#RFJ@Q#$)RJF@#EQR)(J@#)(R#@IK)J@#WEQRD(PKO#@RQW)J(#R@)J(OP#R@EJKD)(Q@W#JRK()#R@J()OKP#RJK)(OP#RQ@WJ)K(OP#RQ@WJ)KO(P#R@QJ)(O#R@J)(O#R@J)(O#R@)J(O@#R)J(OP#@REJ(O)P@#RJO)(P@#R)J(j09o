-- Fake R6 Character - LAG FIXED & HEAD SIZE REDUCED & HEAD SIZE REDUCED
-- Current Date and Time (UTC - YYYY-MM-DD HH:MM:SS formatted): 2025-04-30 08:51:42
-- Current User's Login: 9keefmovement

-- Get Building Tools
local player = game.Players.LocalPlayer
local buildingTools = player.Backpack:FindFirstChild("Building Tools") or (player.Character and player.Character:FindFirstChild("Building Tools"))

if not buildingTools then
    local message = Instance.new("Message")
    message.Text = "Building Tools not found! Please take out F3X Building Tools first."
    message.Parent = workspace
    wait(3)
    message:Destroy()
    return
end

-----------------
-- CORE VARIABLES
-----------------
local character = player.Character
if not character then return end
local humanoid = character:FindFirstChildOfClass("Humanoid")
local hrp = character:FindFirstChild("HumanoidRootPart")
local camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local terrain = workspace.Terrain
local mouse = player:GetMouse()

-- Store original states
local originalCameraSubject = camera.CameraSubject
local originalCameraType = camera.CameraType

-- Parts collection
local fakeParts = {}
local active = true
local lastPartCreated = tick()
local partUpdateQueue = {} -- Queue for parts that need updating
local lastServerSync = 0    -- Last time we sent updates to server

-- Custom asset IDs for Immortality Lord Character
local FACE_ID = "rbxassetid://15654927653"
local HEAD_MESH_ID = "rbxasset://fonts/head.mesh"
local RIGHTARM_MESH_ID = "rbxasset://fonts/rightarm.mesh"
local TORSO_MESH_ID = "rbxasset://fonts/torso.mesh"
local SWORD_MESH_ID = "rbxassetid://1996456880"
local HORNS_MESH_ID = "rbxassetid://3957083206"
local SWIRL_MESH_ID = "rbxassetid://2671071329"
local RIGHT_WING_MESH_ID = "rbxassetid://1553468709"
local LEFT_WING_MESH_ID = "rbxassetid://1553468234"

-- Size multiplier for the character
local S = 1.5  -- Maintain the current size multiplier

-- Character's body color
local body_color = Color3.new(0, 0, 0) -- Black color for the demon lord

-- Camera control
local cameraSettings = {
    distance = 12,           -- Distance from character
    height = 5,              -- Height above character
    rightMouseDown = false,  -- Tracking right mouse button
    sensitivity = 0.5,       -- Camera rotation sensitivity
    yaw = 0,                 -- Horizontal camera angle
    pitch = 0.5,             -- Vertical camera angle (slightly looking down)
    minPitch = -0.5,         -- Minimum pitch (looking up limit)
    maxPitch = 1.2,          -- Maximum pitch (looking down limit)
    minDistance = 5,         -- Minimum camera distance
    maxDistance = 50         -- Maximum camera distance
}

-- Movement settings
local SETTINGS = {
    MOVE_SPEED = 15,          -- Speed for map exploration
    TURN_SPEED = 8,           -- How fast character rotates to face direction
    ACCELERATION = 0.3,       -- Acceleration rate
    DECELERATION = 0.5,       -- Deceleration rate
    WALK_ANIMATION_SPEED = 8, -- Animation cycling speed
    GROUND_CHECK = true,      -- Enable terrain height following
    SERVER_SYNC_INTERVAL = 0.1, -- Longer interval to reduce lag spikes
    ANIMATION_STRENGTH = 0.25,  -- Even less animation to keep parts together
    LOCAL_UPDATE_THROTTLE = 0.01 -- Local updates can happen more frequently
}

-- Character structure with proper proportions and depth
local CHARACTER_STRUCTURE = {
    Torso = {offset = Vector3.new(0, 0, 0), size = Vector3.new(2, 2, 1.25) * S, meshId = TORSO_MESH_ID, meshScale = Vector3.new(2, 2, 1.8) * S},
    Head = {offset = Vector3.new(0, 2.0, 0) * S, size = Vector3.new(1.25, 1.25, 1.25) * S, meshId = HEAD_MESH_ID, meshScale = Vector3.new(2, 2, 1.8) * S}, -- Head Y offset increased
    LeftArm = {offset = Vector3.new(-1.1, 0.5, 0) * S, size = Vector3.new(1, 2, 1) * S, meshId = RIGHTARM_MESH_ID, meshScale = Vector3.new(2, 2, 1.8) * S},
    RightArm = {offset = Vector3.new(1.1, 0.5, 0) * S, size = Vector3.new(1, 2, 1) * S, meshId = RIGHTARM_MESH_ID, meshScale = Vector3.new(2, 2, 1.8) * S},
    LeftLeg = {offset = Vector3.new(-1.1, -3, 0) * S, size = Vector3.new(1, 2, 1) * S, meshId = RIGHTARM_MESH_ID, meshScale = Vector3.new(2, 2, 1.8) * S},
    RightLeg = {offset = Vector3.new(1.1, -3, 0) * S, size = Vector3.new(1, 2, 1) * S, meshId = RIGHTARM_MESH_ID, meshScale = Vector3.new(2, 2, 1.8) * S},
    Eyes = {offset = Vector3.new(0.144, -0.152, 0.91) * S, size = Vector3.new(0.338167071, 0.505675316, 0.170242548) * S, color = Color3.new(1, 1, 1)},
    Sword = {offset = Vector3.new(0, -3.15, 0) * S, size = Vector3.new(0.780644, 5, 1.5) * S, meshId = SWORD_MESH_ID, meshScale = Vector3.new(3, 3, 3) * S},
    Horns = {offset = Vector3.new(0, 0.5, -0.4) * S, size = Vector3.new(1.42972004, 1.43829918, 0.512506962) * S, meshId = HORNS_MESH_ID, meshScale = Vector3.new(1.5, 1.5, 1.5) * S},
    RightWing = {offset = Vector3.new(1.1, 1, -0.75) * S, size = Vector3.new(2.398, 4.324, 1.922) * S, meshId = RIGHT_WING_MESH_ID, meshScale = Vector3.new(0.07, 0.07, 0.07) * S},
    LeftWing = {offset = Vector3.new(-1.1, 1, 0.75) * S, size = Vector3.new(2.398, 4.324, 1.922) * S, meshId = LEFT_WING_MESH_ID, meshScale = Vector3.new(0.07, 0.07, 0.07) * S}
}

-- Welds configuration with better leg spacing and wing positioning
local WELD_CONFIGURATION = {
    Neck = {
        C0 = CFrame.new(0, 2.0*S, 0) * CFrame.Angles(math.rad(-90), 0, math.rad(180)), -- Neck C0 Y offset increased
        C1 = CFrame.new(0, -0.5*S, 0) * CFrame.Angles(math.rad(-90), 0, math.rad(180))
    },
    RootJoint = {
        C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-90), 0, math.rad(180)),
        C1 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-90), 0, math.rad(180))
    },
    RightShoulder = {
        C0 = CFrame.new(1*S, 0.5*S, 0) * CFrame.Angles(0, math.rad(90), 0),
        C1 = CFrame.new(-0.5*S, 0.5*S, 0) * CFrame.Angles(0, math.rad(90), 0)
    },
    LeftShoulder = {
        C0 = CFrame.new(-1*S, 0.5*S, 0) * CFrame.Angles(0, math.rad(-90), 0),
        C1 = CFrame.new(0.5*S, 0.5*S, 0) * CFrame.Angles(0, math.rad(-90), 0)
    },
    RightHip = {
        C0 = CFrame.new(1.1*S, -3*S, 0) * CFrame.Angles(0, math.rad(90), 0),
        C1 = CFrame.new(0.5*S, 1*S, 0) * CFrame.Angles(0, math.rad(90), 0)
    },
    LeftHip = {
        C0 = CFrame.new(-1.1*S, -3*S, 0) * CFrame.Angles(0, math.rad(-90), 0),
        C1 = CFrame.new(-0.5*S, 1*S, 0) * CFrame.Angles(0, math.rad(-90), 0)
    },
    Eyes = {
        C0 = CFrame.new(0, 0, 0),
        C1 = CFrame.new(0.143993527*S, -0.15178299*S, 0.91*S) * CFrame.fromEulerAnglesXYZ(0, 0, 0) * CFrame.Angles(0, math.rad(15), 0)
    },
    Sword = {
        C0 = CFrame.new(0, -1*S, 0) * CFrame.Angles(math.rad(90), 0, 0),
        C1 = CFrame.new(0, -3.15*S, 0)
    },
    Horns = {
        C0 = CFrame.new(0, 1*S, -0.4*S),
        C1 = CFrame.new(0, 0, 0)
    },
    RightWing = {
        C0 = CFrame.new(0.5*S, 0.5*S, 0.5*S) * CFrame.Angles(0, math.rad(90), 0),
        C1 = CFrame.new(1.1*S, 1*S, -0.75*S)
    },
    LeftWing = {
        C0 = CFrame.new(-0.5*S, 0.5*S, 0.5*S) * CFrame.Angles(0, math.rad(90), 0),
        C1 = CFrame.new(1.1*S, 1*S, 0.75*S) -- Fixed: X is positive, matching fileToEdit.lua for LeftWing.C1
    }
}

-- Movement state
local movementState = {
    moveVector = Vector3.new(0, 0, 0),
    facingAngle = 0,
    targetFacingAngle = 0,
    velocity = Vector3.new(0, 0, 0),
    isMoving = false,
    moveDirection = Vector3.new(0, 0, 0),
    keys = {w=false, a=false, s=false, d=false},
    animationTime = 0,
    currentHeight = 0,
    lastLocalUpdate = 0,
    NeckSnap = false,
    Flying = false,
    Falling = false,
    WalkSpeed = 16*S,  -- Match fileToEdit.lua
    HipHeight = 8*S    -- Increased hip height for higher levitation
}

-- Connection trackers
local connections = {}

-- Initialize welds with correct configuration from fileToEdit.lua
local welds = {
    RootJoint = { C0 = WELD_CONFIGURATION.RootJoint.C0, C1 = WELD_CONFIGURATION.RootJoint.C1 },
    Neck = { C0 = WELD_CONFIGURATION.Neck.C0, C1 = WELD_CONFIGURATION.Neck.C1 },
    RightShoulder = { C0 = WELD_CONFIGURATION.RightShoulder.C0, C1 = WELD_CONFIGURATION.RightShoulder.C1 },
    LeftShoulder = { C0 = WELD_CONFIGURATION.LeftShoulder.C0, C1 = WELD_CONFIGURATION.LeftShoulder.C1 },
    RightHip = { C0 = WELD_CONFIGURATION.RightHip.C0, C1 = WELD_CONFIGURATION.RightHip.C1 },
    LeftHip = { C0 = WELD_CONFIGURATION.LeftHip.C0, C1 = WELD_CONFIGURATION.LeftHip.C1 },
    Eyes = { C0 = WELD_CONFIGURATION.Eyes.C0, C1 = WELD_CONFIGURATION.Eyes.C1 },
    Sword = { C0 = WELD_CONFIGURATION.Sword.C0, C1 = WELD_CONFIGURATION.Sword.C1 },
    Horns = { C0 = WELD_CONFIGURATION.Horns.C0, C1 = WELD_CONFIGURATION.Horns.C1 },
    RightWing = { C0 = WELD_CONFIGURATION.RightWing.C0, C1 = WELD_CONFIGURATION.RightWing.C1 },
    LeftWing = { C0 = WELD_CONFIGURATION.LeftWing.C0, C1 = WELD_CONFIGURATION.LeftWing.C1 },
    Defaults = {
        Neck = { C0 = WELD_CONFIGURATION.Neck.C0 },
        RootJoint = { C0 = WELD_CONFIGURATION.RootJoint.C0 },
        RightShoulder = { C0 = WELD_CONFIGURATION.RightShoulder.C0 },
        LeftShoulder = { C0 = WELD_CONFIGURATION.LeftShoulder.C0 }
    }
}

-----------------
-- UTILITY FUNCTIONS
-----------------

-- Safe message display
local function showMessage(text, duration)
    local msg = Instance.new("Message")
    msg.Text = text
    msg.Parent = workspace
    task.delay(duration or 3, function()
        pcall(function() msg:Destroy() end)
    end)
end

-- Create part with API throttling protection
local function createPartSafely(name, size, position, color, material, parent)
    -- Don't create parts too quickly
    local timeSinceLastPart = tick() - lastPartCreated
    if timeSinceLastPart < 0.35 then
        wait(0.35 - timeSinceLastPart)
    end
    
    local part = nil
    pcall(function()
        local args = {
            [1] = "CreatePart",
            [2] = "Normal",
            [3] = CFrame.new(position),
            [4] = parent or workspace
        }
        
        part = buildingTools.SyncAPI.ServerEndpoint:InvokeServer(unpack(args))
        
        if part then
            part.Name = name
            
            -- Set size
            buildingTools.SyncAPI.ServerEndpoint:InvokeServer(
                "SyncResize",
                {
                    [1] = {
                        ["Part"] = part,
                        ["CFrame"] = CFrame.new(position),
                        ["Size"] = size
                    }
                }
            )
            
            -- Set color
            buildingTools.SyncAPI.ServerEndpoint:InvokeServer(
                "SyncColor",
                {
                    [1] = {
                        ["Color"] = color,
                        ["UnionColoring"] = true,
                        ["Part"] = part
                    }
                }
            )
            
            -- Set material
            buildingTools.SyncAPI.ServerEndpoint:InvokeServer(
                "SyncMaterial",
                {
                    [1] = {
                        ["Part"] = part,
                        ["Material"] = material
                    }
                }
            )
            
            -- Make sure it's anchored
            buildingTools.SyncAPI.ServerEndpoint:InvokeServer(
                "SyncAnchor",
                {
                    [1] = {
                        ["Part"] = part,
                        ["Anchored"] = true
                    }
                }
            )
            
            -- Set parent to terrain if requested
            if parent == terrain then
                buildingTools.SyncAPI.ServerEndpoint:InvokeServer(
                    "SetParent",
                    {
                        [1] = {
                            ["Part"] = part,
                            ["Parent"] = terrain
                        }
                    }
                )
            end
        end
    end)
    
    lastPartCreated = tick()
    return part
end

-- Queue part for server update
local function queuePartForUpdate(part, newCFrame)
    if not part or not part.Parent then return false end
    
    -- Update locally immediately for responsive movement
    part.CFrame = newCFrame
    
    -- Add to queue for server sync
    for i, item in ipairs(partUpdateQueue) do
        if item.part == part then
            -- Update existing entry
            partUpdateQueue[i].cframe = newCFrame
            return true
        end
    end
    
    -- Add new entry
    table.insert(partUpdateQueue, {
        part = part,
        cframe = newCFrame
    })
    
    return true
end

-- Process all queued part updates to server
local function processPartUpdateQueue()
    if #partUpdateQueue == 0 then return end
    
    -- Create batch update table
    local batchUpdate = {}
    for _, item in ipairs(partUpdateQueue) do
        table.insert(batchUpdate, {
            ["Part"] = item.part,
            ["CFrame"] = item.cframe
        })
    end
    
    -- Send batch update to server
    pcall(function()
        buildingTools.SyncAPI.ServerEndpoint:InvokeServer(
            "SyncMove", 
            batchUpdate
        )
    end)
    
    -- Clear queue
    partUpdateQueue = {}
    lastServerSync = tick()
end

-- Clean up everything safely
local function cleanupEverything()
    -- Stop active state
    active = false
    
    -- Disconnect all connections
    for _, conn in pairs(connections) do
        if conn then 
            pcall(function() conn:Disconnect() end)
        end
    end
    connections = {}
    
    -- Remove parts with delays to avoid API throttling
    for name, part in pairs(fakeParts) do
        if part and part.Parent then
            pcall(function()
                buildingTools.SyncAPI.ServerEndpoint:InvokeServer("Remove", {part})
            end)
            wait(0.1) -- Small delay between removals
        end
    end
    fakeParts = {}
    
    -- Clear update queue
    partUpdateQueue = {}
    
    -- Restore character
    pcall(function()
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Transparency = 0
            end
        end
        
        if humanoid then
            humanoid.WalkSpeed = 16
            humanoid.JumpPower = 50
        end
    end)
    
    -- Restore camera
    pcall(function()
        camera.CameraType = originalCameraType
        camera.CameraSubject = originalCameraSubject
    end)
    
    showMessage("Fake character removed.", 2)
end

-- Make character invisible
local function hideCharacter()
    pcall(function()
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Transparency = 1
            end
        end
        
        -- Disable character movement so it doesn't interfere
        humanoid.WalkSpeed = 0
        humanoid.JumpPower = 0
    end)
end

-- Find ground height at position
local function getGroundHeight(position)
    -- Cast a ray downward to find the ground
    local rayOrigin = Vector3.new(position.X, position.Y + 10, position.Z)
    local rayDirection = Vector3.new(0, -50, 0) -- Look 50 studs down
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    -- Filter out the fake character parts
    local filterTable = {}
    for _, part in pairs(fakeParts) do
        if part and part.Parent then
            table.insert(filterTable, part)
        end
    end
    raycastParams.FilterDescendantsInstances = filterTable
    
    -- Perform raycast
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    
    if raycastResult then
        -- Found ground, return its height plus offset for character (increased for higher levitation)
        return raycastResult.Position.Y + 12 -- Character stands even higher above ground
    else
        -- No ground found, return current height
        return position.Y
    end
end

-- Calculate camera position based on yaw and pitch
local function calculateCameraPosition(characterPosition)
    -- Calculate camera direction from yaw and pitch
    local yawRad = cameraSettings.yaw
    local pitchRad = cameraSettings.pitch
    
    -- Direction vector based on angles
    local dirX = math.sin(yawRad) * math.cos(pitchRad)
    local dirY = math.sin(pitchRad)
    local dirZ = math.cos(yawRad) * math.cos(pitchRad)
    
    -- Camera direction normalized
    local cameraDir = Vector3.new(dirX, dirY, dirZ).Unit
    
    -- Calculate camera position at set distance from character
    local cameraPos = characterPosition + Vector3.new(0, 1.5, 0) -- Head height offset
                      - (cameraDir * cameraSettings.distance)   -- Move back from character
    
    return cameraPos, cameraDir
end

-- Helper function for smooth value interpolation
local function Clerp(a, b, t)
    -- Get current time for animation throttling
    local Timing = {Throttle = 1}
    return a:Lerp(b, t < 1 and math.clamp(t * Timing.Throttle, 0, 1) or 1)
end

-- Update weld position
local function UpdateWeld(Weld, Part1, Part0)
    if not Part1 or not Part0 then return end
    Part1.CFrame = Part0.CFrame * (Weld.C0 * Weld.C1:Inverse())
end

-----------------
-- CORE FUNCTIONS
-----------------

-- Set up camera controls with right-click rotation
local function setupCameraControls()
    -- Mouse button controls
    local mouseButtonDown = UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        
        if input.UserInputType == Enum.UserInputType.MouseButton2 then
            -- Right mouse button down - enable camera rotation
            cameraSettings.rightMouseDown = true
            -- Hide mouse cursor when rotating camera
            UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
        end
    end)
    
    local mouseButtonUp = UserInputService.InputEnded:Connect(function(input, processed)
        if input.UserInputType == Enum.UserInputType.MouseButton2 then
            -- Right mouse button up - disable camera rotation
            cameraSettings.rightMouseDown = false
            -- Show mouse cursor again
            UserInputService.MouseBehavior = Enum.MouseBehavior.Default
        end
    end)
    
    -- Mouse movement for camera rotation
    local mouseMove = UserInputService.InputChanged:Connect(function(input, processed)
        if input.UserInputType == Enum.UserInputType.MouseMovement and cameraSettings.rightMouseDown then
            -- Adjust yaw (horizontal) and pitch (vertical) based on mouse movement
            cameraSettings.yaw = cameraSettings.yaw - input.Delta.X * cameraSettings.sensitivity * 0.01
            cameraSettings.pitch = cameraSettings.pitch - input.Delta.Y * cameraSettings.sensitivity * 0.01
            
            -- Limit pitch to prevent camera flipping
            cameraSettings.pitch = math.clamp(
                cameraSettings.pitch, 
                cameraSettings.minPitch, 
                cameraSettings.maxPitch
            )
            
            -- Update movement vector based on new camera orientation
            updateMoveVector()
        end
    end)
    
    -- Mouse wheel for zoom in/out
    local mouseWheel = UserInputService.InputChanged:Connect(function(input, processed)
        if input.UserInputType == Enum.UserInputType.MouseWheel then
            -- Adjust camera distance based on scroll direction
            cameraSettings.distance = math.clamp(
                cameraSettings.distance - (input.Position.Z * 2),
                cameraSettings.minDistance,
                cameraSettings.maxDistance
            )
        end
    end)
    
    -- Store connections
    table.insert(connections, mouseButtonDown)
    table.insert(connections, mouseButtonUp)
    table.insert(connections, mouseMove)
    table.insert(connections, mouseWheel)
    
    return true
end

-- Create character with fixed positions based on fileToEdit.lua
local function createCharacter()
    local startPos = hrp.Position
    
    showMessage("Creating Immortality Lord character...", 1)
    
    -- Create torso first - this will be our reference part
    fakeParts.Torso = createPartSafely(
        "FakeTorso",
        CHARACTER_STRUCTURE.Torso.size,
        Vector3.new(startPos.X, startPos.Y, startPos.Z),
        body_color,
        Enum.Material.Slate,
        terrain
    )
    
    if not fakeParts.Torso or not fakeParts.Torso.Parent then
        showMessage("Failed to create torso! Aborting.", 3)
        return false
    end
    
    wait(0.2)
    
    -- Store initial parameters
    movementState.currentHeight = startPos.Y
    
    -- Create head above torso with correct offset
    fakeParts.Head = createPartSafely(
        "FakeHead",
        CHARACTER_STRUCTURE.Head.size,
        fakeParts.Torso.Position + CHARACTER_STRUCTURE.Head.offset,
        body_color,
        Enum.Material.Slate,
        terrain
    )
    wait(0.2)
    
    -- Create arms with correct offset
    fakeParts.LeftArm = createPartSafely(
        "FakeLeftArm",
        CHARACTER_STRUCTURE.LeftArm.size,
        fakeParts.Torso.Position + CHARACTER_STRUCTURE.LeftArm.offset,
        body_color,
        Enum.Material.Slate,
        terrain
    )
    wait(0.2)
    
    fakeParts.RightArm = createPartSafely(
        "FakeRightArm",
        CHARACTER_STRUCTURE.RightArm.size,
        fakeParts.Torso.Position + CHARACTER_STRUCTURE.RightArm.offset,
        body_color,
        Enum.Material.Slate,
        terrain
    )
    wait(0.2)
    
    -- Create legs with correct offset
    fakeParts.LeftLeg = createPartSafely(
        "FakeLeftLeg",
        CHARACTER_STRUCTURE.LeftLeg.size,
        fakeParts.Torso.Position + CHARACTER_STRUCTURE.LeftLeg.offset,
        body_color,
        Enum.Material.Slate,
        terrain
    )
    wait(0.2)
    
    fakeParts.RightLeg = createPartSafely(
        "FakeRightLeg",
        CHARACTER_STRUCTURE.RightLeg.size,
        fakeParts.Torso.Position + CHARACTER_STRUCTURE.RightLeg.offset,
        body_color,
        Enum.Material.Slate,
        terrain
    )
    wait(0.2)
    
    -- Create eyes with correct offset and position
    fakeParts.Eyes = createPartSafely(
        "FakeEyes",
        CHARACTER_STRUCTURE.Eyes.size,
        fakeParts.Head.Position + CHARACTER_STRUCTURE.Eyes.offset,
        CHARACTER_STRUCTURE.Eyes.color,
        Enum.Material.Neon,
        terrain
    )
    wait(0.2)
    
    -- Create sword attached to right arm
    fakeParts.Sword = createPartSafely(
        "FakeSword",
        CHARACTER_STRUCTURE.Sword.size,
        fakeParts.RightArm.Position + CHARACTER_STRUCTURE.Sword.offset,
        body_color,
        Enum.Material.Slate,
        terrain
    )
    wait(0.2)
    
    -- Create horns on head
    fakeParts.Horns = createPartSafely(
        "FakeHorns",
        CHARACTER_STRUCTURE.Horns.size,
        fakeParts.Head.Position + CHARACTER_STRUCTURE.Horns.offset,
        body_color,
        Enum.Material.Slate,
        terrain
    )
    wait(0.2)
    
    -- Create wings on torso
    fakeParts.RightWing = createPartSafely(
        "FakeRightWing",
        CHARACTER_STRUCTURE.RightWing.size,
        fakeParts.Torso.Position + CHARACTER_STRUCTURE.RightWing.offset,
        body_color,
        Enum.Material.Slate,
        terrain
    )
    wait(0.2)
    
    fakeParts.LeftWing = createPartSafely(
        "FakeLeftWing",
        CHARACTER_STRUCTURE.LeftWing.size,
        fakeParts.Torso.Position + CHARACTER_STRUCTURE.LeftWing.offset,
        body_color,
        Enum.Material.Slate,
        terrain
    )
    wait(0.2)
    
    -- Apply meshes to all parts
    local partsWithMeshes = {"Head", "Torso", "RightArm", "LeftArm", "RightLeg", "LeftLeg", "Sword", "Horns", "RightWing", "LeftWing"}
    
    for _, partName in ipairs(partsWithMeshes) do
        local part = fakeParts[partName]
        local meshData = CHARACTER_STRUCTURE[partName]
        
        if part and part.Parent and meshData.meshId then
            pcall(function()
                -- Create mesh
                buildingTools.SyncAPI.ServerEndpoint:InvokeServer(
                    "CreateMeshes",
                    {
                        [1] = {
                            ["Part"] = part
                        }
                    }
                )
                
                wait(0.1)
                
                -- Apply mesh properties
                buildingTools.SyncAPI.ServerEndpoint:InvokeServer(
                    "SyncMesh",
                    {
                        [1] = {
                            ["Part"] = part,
                            ["MeshType"] = Enum.MeshType.FileMesh,
                            ["MeshId"] = meshData.meshId,
                            ["Scale"] = meshData.meshScale
                        }
                    }
                )
                
                wait(0.1)
            end)
        end
    end
    
    -- Configure collision properties
    for partName, part in pairs(fakeParts) do
        if part and part.Parent then
            if partName == "Eyes" then
                -- Eyes can't collide
                buildingTools.SyncAPI.ServerEndpoint:InvokeServer(
                    "SyncCollision",
                    {
                        [1] = {
                            ["Part"] = part,
                            ["CanCollide"] = false
                        }
                    }
                )
            elseif partName == "Sword" or partName == "Horns" or partName == "RightWing" or partName == "LeftWing" then
                -- These parts need PreciseConvexDecomposition collision
                buildingTools.SyncAPI.ServerEndpoint:InvokeServer(
                    "SyncCollision",
                    {
                        [1] = {
                            ["Part"] = part,
                            ["CollisionFidelity"] = Enum.CollisionFidelity.PreciseConvexDecomposition
                        }
                    }
                )
            end
        end
    end
    
    -- Check all essential parts
    local essentialParts = {"Torso", "Head", "LeftArm", "RightArm", "LeftLeg", "RightLeg", "Eyes", "Sword", "Horns", "RightWing", "LeftWing"}
    for _, partName in ipairs(essentialParts) do
        if not fakeParts[partName] or not fakeParts[partName].Parent then
            showMessage("Failed to create " .. partName .. "! Aborting.", 3)
            return false
        end
    end
    
    -- Create HumanoidRootPart reference for positioning
    fakeParts.HumanoidRootPart = {CFrame = CFrame.new(startPos)}
    
    return true
end

-- Set up movement controls - using camera direction based on camera rotation
local function setupMovementControls()
    -- Key press detection
    local inputBegan = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.KeyCode == Enum.KeyCode.W then
            movementState.keys.w = true
            updateMoveVector()
        elseif input.KeyCode == Enum.KeyCode.A then
            movementState.keys.a = true
            updateMoveVector()
        elseif input.KeyCode == Enum.KeyCode.S then
            movementState.keys.s = true
            updateMoveVector()
        elseif input.KeyCode == Enum.KeyCode.D then
            movementState.keys.d = true
            updateMoveVector()
        elseif input.KeyCode == Enum.KeyCode.F then
            movementState.Flying = not movementState.Flying
            movementState.Falling = false
        elseif input.KeyCode == Enum.KeyCode.P then -- Emergency exit
            cleanupEverything()
        elseif input.KeyCode == Enum.KeyCode.BackSlash then
            movementState.CFrame = movementState.CFrame * CFrame.new(0, 100, 0)
        end
    end)
    
    -- Key release detection
    local inputEnded = UserInputService.InputEnded:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.KeyCode == Enum.KeyCode.W then
            movementState.keys.w = false
            updateMoveVector()
        elseif input.KeyCode == Enum.KeyCode.A then
            movementState.keys.a = false
            updateMoveVector()
        elseif input.KeyCode == Enum.KeyCode.S then
            movementState.keys.s = false
            updateMoveVector()
        elseif input.KeyCode == Enum.KeyCode.D then
            movementState.keys.d = false
            updateMoveVector()
        end
    end)
    
    -- Update move vector based on camera direction
    function updateMoveVector()
        local moveVec = Vector3.new(0, 0, 0)
        
        -- Get camera's forward direction (based on yaw only, ignoring pitch)
        local camForward = Vector3.new(math.sin(cameraSettings.yaw), 0, math.cos(cameraSettings.yaw)).Unit
        local camRight = Vector3.new(math.sin(cameraSettings.yaw + math.pi/2), 0, math.cos(cameraSettings.yaw + math.pi/2)).Unit
        
        -- Apply movement relative to camera direction
        if movementState.keys.w then
            moveVec = moveVec + camForward  -- W moves in camera forward direction
        end
        if movementState.keys.s then
            moveVec = moveVec - camForward  -- S moves opposite camera forward direction
        end
        
        -- Left/right movement
        if movementState.keys.a then
            moveVec = moveVec - camRight  -- A moves left of camera
        end
        if movementState.keys.d then
            moveVec = moveVec + camRight  -- D moves right of camera
        end
        
        -- Normalize if needed
        if moveVec.Magnitude > 0 then
            moveVec = moveVec.Unit
        end
        
        movementState.moveVector = moveVec
        movementState.isMoving = moveVec.Magnitude > 0
        
        -- Face direction of movement if moving
        if movementState.isMoving then
            movementState.moveDirection = moveVec
            movementState.targetFacingAngle = math.atan2(-moveVec.X, -moveVec.Z)
        end
    end
    
    -- Character reset detection
    local charChanged = player.CharacterAdded:Connect(function()
        cleanupEverything()
    end)
    
    -- Store connections
    table.insert(connections, inputBegan)
    table.insert(connections, inputEnded)
    table.insert(connections, charChanged)
    
    -- Show instructions
    showMessage("Controls ready! WASD to move, right-click to rotate camera. Press P to exit.", 3)
    
    return true
end

-- Setup server sync timer to separate rendering from network operations
local function setupServerSyncTimer()
    local updateConnection = RunService.Heartbeat:Connect(function()
        if not active then return end
        
        -- Check if we need to sync with server
        local currentTime = tick()
        if currentTime - lastServerSync >= SETTINGS.SERVER_SYNC_INTERVAL and #partUpdateQueue > 0 then
            processPartUpdateQueue()
        end
    end)
    
    table.insert(connections, updateConnection)
    return true
end

-- Update character movement and animation with adjusted leg positioning
local function updateMovement(deltaTime)
    -- Safety check
    if not active or not fakeParts.Torso or not fakeParts.Torso.Parent then
        return false
    end
    
    -- Create timing variable for animations
    local Timing = {
        Sine = tick() * 60,  -- Matching fileToEdit.lua's timing system
        Throttle = 1
    }
    
    -- Throttle local updates to reduce CPU usage
    local currentTime = tick()
    if currentTime - movementState.lastLocalUpdate < SETTINGS.LOCAL_UPDATE_THROTTLE then
        return true
    end
    movementState.lastLocalUpdate = currentTime
    
    -- 1. Update character facing angle with smooth turning
    local angleDiff = (movementState.targetFacingAngle - movementState.facingAngle) % (math.pi * 2)
    if angleDiff > math.pi then angleDiff = angleDiff - math.pi * 2 end
    
    movementState.facingAngle = movementState.facingAngle + 
        math.clamp(angleDiff, -deltaTime * SETTINGS.TURN_SPEED, deltaTime * SETTINGS.TURN_SPEED)
    
    -- 2. Calculate target velocity in world space
    local targetVelocity = Vector3.new(0, 0, 0)
    if movementState.isMoving then
        targetVelocity = movementState.moveDirection * movementState.WalkSpeed
    end
    
    -- 3. Smooth acceleration/deceleration
    local accelRate = movementState.isMoving and SETTINGS.ACCELERATION or SETTINGS.DECELERATION
    movementState.velocity = movementState.velocity:Lerp(targetVelocity, math.min(1, accelRate * deltaTime * 10))
    
    -- 4. Apply movement - no boundaries on XZ plane for full map movement
    local moveOffset = movementState.velocity * deltaTime
    
    -- Get current torso position
    local currentPos = fakeParts.Torso.Position
    local newPosition = Vector3.new(
        currentPos.X + moveOffset.X,
        currentPos.Y, -- Height updated later
        currentPos.Z + moveOffset.Z
    )
    
    -- 5. Adjust height to follow terrain
    if SETTINGS.GROUND_CHECK and not movementState.Flying then
        local targetHeight = getGroundHeight(newPosition)
        -- Smooth height adjustment - slower to reduce body separation
        movementState.currentHeight = movementState.currentHeight + 
            (targetHeight - movementState.currentHeight) * math.min(1, deltaTime * 3)
        newPosition = Vector3.new(newPosition.X, movementState.currentHeight, newPosition.Z)
        
        -- Check if we're falling
        if (movementState.currentHeight - targetHeight) > 1 * S then
            movementState.Falling = true
        else
            movementState.Falling = false
        end
    end
    
    -- 6. Calculate base torso CFrame
    local torsoCF = CFrame.new(newPosition) * CFrame.Angles(0, movementState.facingAngle, 0)
    movementState.CFrame = torsoCF -- Store current movement CFrame
    fakeParts.HumanoidRootPart.CFrame = torsoCF * CFrame.new(0, movementState.HipHeight, 0) -- Store for reference
    
    -- Batch update for server synchronization
    local partBatchUpdate = {}
    
    -- Apply animations based on fileToEdit.lua patterns
    if movementState.isMoving then
        -- Walking animation
        welds.RootJoint.C0 = Clerp(welds.RootJoint.C0, welds.Defaults.RootJoint.C0 * 
                               CFrame.new(0, 0, -0.5 * math.sin(Timing.Sine/25) * S) * 
                               CFrame.Angles(math.rad(20), 0, 0), 0.25)
                               
        if movementState.NeckSnap then
            welds.Neck.C0 = Clerp(welds.Neck.C0, welds.Defaults.Neck.C0, 1)
            movementState.NeckSnap = false
        else
            welds.Neck.C0 = Clerp(welds.Neck.C0, welds.Defaults.Neck.C0, 0.25)
        end
        
        -- Random neck movement for demonic effect
        if math.random(1, 15) == 1 then
            welds.Neck.C0 = Clerp(welds.Neck.C0, welds.Defaults.Neck.C0 * 
                           CFrame.Angles(math.rad(math.random(-20,20)), 
                                        math.rad(math.random(-20,20)), 
                                        math.rad(math.random(-20,20))), 1)
            movementState.NeckSnap = true
        end
    else
        -- Idle animation
        welds.RootJoint.C0 = Clerp(welds.RootJoint.C0, welds.Defaults.RootJoint.C0 * 
                               CFrame.new(0, 0, -0.5 * math.sin(Timing.Sine/25) * S) * 
                               CFrame.Angles(math.rad(20), 0, 0), 0.25)
                               
        if movementState.NeckSnap then
            welds.Neck.C0 = Clerp(welds.Neck.C0, welds.Defaults.Neck.C0 * 
                          CFrame.Angles(math.rad(20), math.rad(10 * math.sin(Timing.Sine/50)), 0), 1)
            movementState.NeckSnap = false
        else
            welds.Neck.C0 = Clerp(welds.Neck.C0, welds.Defaults.Neck.C0 * 
                          CFrame.Angles(math.rad(20), math.rad(10 * math.sin(Timing.Sine/50)), 0), 0.25)
        end
        
        -- Random neck movement
        if math.random(1, 15) == 1 then
            welds.Neck.C0 = Clerp(welds.Neck.C0, welds.Defaults.Neck.C0 * 
                           CFrame.Angles(math.rad(20 + math.random(-20,20)), 
                                       math.rad((10 * math.sin(Timing.Sine/50)) + math.random(-20,20)), 
                                       math.rad(math.random(-20,20))), 1)
            movementState.NeckSnap = true
        end
    end
    
    -- Arms with proper shoulder positioning - closer to torso
    if fakeParts.LeftArm and fakeParts.LeftArm.Parent then
        if not movementState.Flying and not movementState.Falling then
            welds.LeftShoulder.C0 = Clerp(welds.LeftShoulder.C0, 
                                     CFrame.new(-1.1*S, 0.5*S, 0) * 
                                     CFrame.Angles(math.rad(20), 0, 
                                                 math.rad(-10 - 10*math.cos(Timing.Sine/25))) * 
                                     welds.Defaults.LeftShoulder.C0, 0.25)
        else
            welds.LeftShoulder.C0 = Clerp(welds.LeftShoulder.C0, 
                                     CFrame.new(-1.1*S, 0.5*S, 0) * 
                                     CFrame.Angles(math.rad(20), 0, 
                                                 math.rad(-10 - 10*math.cos(Timing.Sine/25))) * 
                                     welds.Defaults.LeftShoulder.C0, 0.25)
        end
    end
    
    if fakeParts.RightArm and fakeParts.RightArm.Parent then
        if not movementState.Flying and not movementState.Falling then
            welds.RightShoulder.C0 = Clerp(welds.RightShoulder.C0, 
                                      CFrame.new(1.1*S, 0.5*S, 0) * 
                                      CFrame.Angles(math.rad(-10), 0, 0) * 
                                      welds.Defaults.RightShoulder.C0, 0.25)
            welds.Sword.C0 = Clerp(welds.Sword.C0, 
                             CFrame.new(0, -1*S, 0) * 
                             CFrame.Angles(math.rad(154.35 - 5.65*math.sin(Timing.Sine/25)), 0, 0), 0.25)
        else
            welds.RightShoulder.C0 = Clerp(welds.RightShoulder.C0, 
                                      CFrame.new(1.1*S, 0.5*S, 0) * 
                                      CFrame.Angles(math.rad(80 + 5*math.cos(Timing.Sine/25)), 0, math.rad(45)) * 
                                      welds.Defaults.RightShoulder.C0, 0.25)
            welds.Sword.C0 = Clerp(welds.Sword.C0, 
                             CFrame.new(0, 0, -0.5*S) * 
                             CFrame.Angles(0, math.rad(170), math.rad(-10)), 0.25)
        end
    end
    
    -- Legs with better hip positioning - wider stance and no crossing
    if fakeParts.LeftLeg and fakeParts.LeftLeg.Parent then
        if movementState.isMoving then
            welds.LeftHip.C0 = Clerp(welds.LeftHip.C0, 
                               CFrame.new(-1.1*S, -3*S, 0) * 
                               CFrame.Angles(math.rad(-10), math.rad(-80), 
                                          math.rad(-10 - 10*math.cos(Timing.Sine/25))), 0.25)
        else
            welds.LeftHip.C0 = Clerp(welds.LeftHip.C0, 
                               CFrame.new(-1.1*S, -3*S, 0) * 
                               CFrame.Angles(math.rad(20), math.rad(-80), 
                                          math.rad(-10 - 10*math.cos(Timing.Sine/25))), 0.25)
        end
    end
    
    if fakeParts.RightLeg and fakeParts.RightLeg.Parent then
        if movementState.isMoving then
            welds.RightHip.C0 = Clerp(welds.RightHip.C0, 
                                CFrame.new(1.1*S, -3*S, 0) * 
                                CFrame.Angles(math.rad(-20), math.rad(80), 
                                           math.rad(10 + 10*math.cos(Timing.Sine/25))), 0.25)
        else
            welds.RightHip.C0 = Clerp(welds.RightHip.C0, 
                                CFrame.new(1.1*S, -3*S, 0) * 
                                CFrame.Angles(math.rad(10), math.rad(80), 
                                           math.rad(10 + 10*math.cos(Timing.Sine/25))), 0.25)
        end
    end
    
    -- Wings with properly mirrored animation exactly matching fileToEdit.lua
    welds.RightWing.C0 = Clerp(welds.RightWing.C0, 
                         CFrame.new(0.5*S, 0.5*S, 0.5*S) * 
                         CFrame.Angles(0, math.rad(105-25*math.cos(Timing.Sine/25)), 0), 0.25)
    
    welds.LeftWing.C0 = Clerp(welds.LeftWing.C0, 
                        CFrame.new(-0.5*S, 0.5*S, 0.5*S) * 
                        CFrame.Angles(0, math.rad(75+25*math.cos(Timing.Sine/25)), 0), 0.25)
    
    -- Now update all parts' positions using welds for consistent positioning
    
    -- Torso position
    fakeParts.Torso.CFrame = torsoCF
    table.insert(partBatchUpdate, {
        ["Part"] = fakeParts.Torso,
        ["CFrame"] = torsoCF
    })
    
    -- Update other parts with welds
    UpdateWeld(welds.Neck, fakeParts.Head, fakeParts.Torso)
    table.insert(partBatchUpdate, {
        ["Part"] = fakeParts.Head,
        ["CFrame"] = fakeParts.Head.CFrame
    })
    
    UpdateWeld(welds.RightShoulder, fakeParts.RightArm, fakeParts.Torso)
    table.insert(partBatchUpdate, {
        ["Part"] = fakeParts.RightArm,
        ["CFrame"] = fakeParts.RightArm.CFrame
    })
    
    UpdateWeld(welds.LeftShoulder, fakeParts.LeftArm, fakeParts.Torso)
    table.insert(partBatchUpdate, {
        ["Part"] = fakeParts.LeftArm,
        ["CFrame"] = fakeParts.LeftArm.CFrame
    })
    
    UpdateWeld(welds.RightHip, fakeParts.RightLeg, fakeParts.Torso)
    table.insert(partBatchUpdate, {
        ["Part"] = fakeParts.RightLeg,
        ["CFrame"] = fakeParts.RightLeg.CFrame
    })
    
    UpdateWeld(welds.LeftHip, fakeParts.LeftLeg, fakeParts.Torso)
    table.insert(partBatchUpdate, {
        ["Part"] = fakeParts.LeftLeg,
        ["CFrame"] = fakeParts.LeftLeg.CFrame
    })
    
    UpdateWeld(welds.Eyes, fakeParts.Eyes, fakeParts.Head)
    table.insert(partBatchUpdate, {
        ["Part"] = fakeParts.Eyes,
        ["CFrame"] = fakeParts.Eyes.CFrame
    })
    
    UpdateWeld(welds.Sword, fakeParts.Sword, fakeParts.RightArm)
    table.insert(partBatchUpdate, {
        ["Part"] = fakeParts.Sword,
        ["CFrame"] = fakeParts.Sword.CFrame
    })
    
    UpdateWeld(welds.Horns, fakeParts.Horns, fakeParts.Head)
    table.insert(partBatchUpdate, {
        ["Part"] = fakeParts.Horns,
        ["CFrame"] = fakeParts.Horns.CFrame
    })
    
    UpdateWeld(welds.RightWing, fakeParts.RightWing, fakeParts.Torso)
    table.insert(partBatchUpdate, {
        ["Part"] = fakeParts.RightWing,
        ["CFrame"] = fakeParts.RightWing.CFrame
    })
    
    UpdateWeld(welds.LeftWing, fakeParts.LeftWing, fakeParts.Torso)
    table.insert(partBatchUpdate, {
        ["Part"] = fakeParts.LeftWing,
        ["CFrame"] = fakeParts.LeftWing.CFrame
    })
    
    -- Update eye color based on NeckSnap state
    if movementState.NeckSnap and fakeParts.Eyes.Color ~= Color3.new(1, 0, 0) then
        buildingTools.SyncAPI.ServerEndpoint:InvokeServer(
            "SyncColor",
            {
                [1] = {
                    ["Color"] = Color3.new(1, 0, 0), -- Red when neck snap is active
                    ["UnionColoring"] = true,
                    ["Part"] = fakeParts.Eyes
                }
            }
        )
    elseif not movementState.NeckSnap and fakeParts.Eyes.Color ~= Color3.new(1, 1, 1) then
        buildingTools.SyncAPI.ServerEndpoint:InvokeServer(
            "SyncColor",
            {
                [1] = {
                    ["Color"] = Color3.new(1, 1, 1), -- White otherwise
                    ["UnionColoring"] = true,
                    ["Part"] = fakeParts.Eyes
                }
            }
        )
    end
    
    -- Send batch update to server using SyncMove
    if #partBatchUpdate > 0 then
        pcall(function()
            buildingTools.SyncAPI.ServerEndpoint:InvokeServer("SyncMove", partBatchUpdate)
        end)
    end
    
    -- Update camera using the calculateCameraPosition function
    camera.CameraType = Enum.CameraType.Scriptable
    
    local cameraPos, lookDir = calculateCameraPosition(newPosition)
    camera.CFrame = CFrame.new(cameraPos, newPosition + Vector3.new(0, 1.5, 0))
    
    return true
end

-- Main function
local function main()
    -- Initialize movement CFrame
    movementState.CFrame = CFrame.new(hrp.Position)
    
    -- Create character
    if not createCharacter() then
        showMessage("Character creation failed! Aborting.", 3)
        return
    end
    
    wait(0.5) -- Wait for character to stabilize
    
    -- Hide real character
    hideCharacter()
    
    -- Setup camera controls first (right-click rotation)
    if not setupCameraControls() then
        showMessage("Camera setup failed! Cleaning up.", 3)
        cleanupEverything()
        return
    end
    
    -- Setup movement controls
    if not setupMovementControls() then
        showMessage("Control setup failed! Cleaning up.", 3)
        cleanupEverything()
        return
    end
    
    -- Setup server sync timer to separate rendering from network operations
    if not setupServerSyncTimer() then
        showMessage("Server sync setup failed! Cleaning up.", 3)
        cleanupEverything()
        return
    end
    
    -- Add epic background music like in the original
    local function createBackgroundMusic()
        if not workspace:FindFirstChild("Epic Music lol") then
            local epicMusic = Instance.new("Sound")
            epicMusic.SoundId = "rbxassetid://1836137187"
            epicMusic.Looped = true
            epicMusic.Name = "Epic Music lol"
            epicMusic.Volume = 2
            epicMusic.Parent = workspace
            epicMusic:Play()
            
            -- Add FOV effect based on music loudness
            local musicConnection = RunService.RenderStepped:Connect(function()
                pcall(function()
                    workspace.CurrentCamera.FieldOfView = 66 + (epicMusic.PlaybackLoudness/50)
                end)
            end)
            
            table.insert(connections, musicConnection)
        end
    end
    
    createBackgroundMusic()
    
    -- Start movement update loop
    local lastTime = tick()
    
    local renderConnection = RunService.RenderStepped:Connect(function()
        local currentTime = tick()
        local deltaTime = currentTime - lastTime
        lastTime = currentTime
        
        if not updateMovement(deltaTime) then
            renderConnection:Disconnect()
            cleanupEverything()
        end
    end)
    
    table.insert(connections, renderConnection)
end

-- Run the script
main()

print("Fake R6 Character - LAG FIXED & HEAD SIZE REDUCED")
print("Current Date and Time (UTC - YYYY-MM-DD HH:MM:SS formatted): 2025-04-30 08:51:42")
print("Current User's Login: 9keefmovement")
